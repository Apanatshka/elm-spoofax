module Expr

imports

Lexical
Common
Pattern
Def

context-free syntax

Expr.Unit  = [()]
Expr.Tuple = [([Expr], [{Expr ", "}+])]
Expr.List  = <[<{Expr ", "}*>]>
Expr.Range = <[<Expr>..<Expr>]>
Expr.Rec   = [{[{RecBind ", "}*]}]
Expr.ADT   = UPPERID

context-free syntax

RecBind.RecBind = [[ID] = [Expr]]

MwIfBranch.MwIfBr = [| [Expr] -> [Expr]]
CaseBranch.CaseBr = [[Pattern] -> [Expr]]

context-free syntax

Expr = Literal

Expr = [([Expr])] {bracket}
Expr = Ref
Expr.QualRef = [[{UPPERID "."}+].[ID]]

Expr.PrefixTupleOp = PREFIXTUPLEOP

Expr.RecRem = [{[ID] - [ID]}]
Expr.RecAdd = [{[ID] | [RecAdd]}]
Expr.RecRen = [{[ID] - [ID] | [RecAdd]}]
Expr.RecUpd = [{[ID] | [{RecUpd ", "}+]}]

RecAdd.RecAdd = [[ID] = [Expr]]
RecUpd.RecUpd = [[ID] <- [Expr]]

syntax

Expr-CF.RecGet = Expr "." ID
Expr.Getter = "." ID

context-free syntax

Expr.If      = [if [Expr]
  then [Expr]
  else [Expr]]

Expr.MwIf    = [if[{MwIfBranch "\n  "}+]]
Expr.Case    = [case [Expr] of
  [{CaseBranch "\n  "}+]]

Expr.Lam     = [\[Pattern+] -> [Expr]]
Expr.App     = [[Expr] [Expr]] {left}
Expr.Let     = [let [{Def "\n"}+]
in [Expr]]

Expr.EBinOp   = [[Expr] [BinOp] [Expr]] {left}

context-free priorities

// Expr.ToBinOp > BinOpExpr.ToExpr,
Expr.App >
Expr.EBinOp > {
  Expr.If
  Expr.MwIf
  Expr.Case
  Expr.Lam
  Expr.Let
}

template options
keyword -/- [A-Za-z0-9\_\']
